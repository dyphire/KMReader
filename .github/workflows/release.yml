name: release

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.current }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect project version changes
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          files: |
            KMReader.xcodeproj/project.pbxproj

      - name: Read marketing version
        id: version
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          set -euo pipefail
          FILE="KMReader.xcodeproj/project.pbxproj"
          if [ ! -f "$FILE" ]; then
            echo "project.pbxproj not found at $FILE" >&2
            exit 1
          fi
          VERSION=$(awk 'match($0,/MARKETING_VERSION = ([^;]+);/,a){gsub(/"/,"",a[1]); print a[1]; exit}' "$FILE")
          if [ -z "$VERSION" ]; then
            echo "MARKETING_VERSION not found in $FILE" >&2
            exit 1
          fi
          echo "Detected MARKETING_VERSION: $VERSION"
          echo "current=$VERSION" >> "$GITHUB_OUTPUT"

      - name: No project change affecting marketing version
        if: steps.changed-files.outputs.any_changed != 'true'
        run: |
          echo "KMReader.xcodeproj/project.pbxproj did not change; skipping release."

  create:
    runs-on: ubuntu-latest
    needs: detect
    if: needs.detect.outputs.version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.detect.outputs.version }}
        run: |
          set -euo pipefail
          TAG="v${VERSION}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists, skipping creation."
          else
            # Check version format: X.Y (stable) vs X.Y.Z (prerelease)
            if echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+$'; then
              echo "Creating stable release: $TAG"
              gh release create "$TAG" --target "$GITHUB_SHA" --title "$TAG" --generate-notes
            else
              echo "Creating prerelease: $TAG"
              gh release create "$TAG" --target "$GITHUB_SHA" --title "$TAG" --generate-notes --prerelease
            fi
          fi

  store:
    runs-on: macos-latest
    needs: [detect, create]
    if: needs.detect.outputs.version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "latest-stable"

      - name: Prepare App Store Connect API key
        id: prepare
        env:
          APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${APP_STORE_CONNECT_API_PRIVATE_KEY}" ]; then
            echo "APP_STORE_CONNECT_API_PRIVATE_KEY is not set." >&2
            exit 1
          fi
          umask 077
          KEY_PATH="$RUNNER_TEMP/appstoreconnect_key.p8"
          printf "%s" "$APP_STORE_CONNECT_API_PRIVATE_KEY" > "$KEY_PATH"
          echo "APP_STORE_CONNECT_API_KEY_PATH=$KEY_PATH" >> "$GITHUB_OUTPUT"

      - name: Prepare exportOptions template
        run: |
          set -euo pipefail
          EXPORT_TEMPLATE="misc/exportOptions.template.plist"
          EXPORT_TEMPLATE_OVERRIDE=".github/misc/exportOptions.template.plist"

          if [ -f "$EXPORT_TEMPLATE_OVERRIDE" ]; then
            cp "$EXPORT_TEMPLATE_OVERRIDE" "$EXPORT_TEMPLATE"
            echo "Copied export options template from $EXPORT_TEMPLATE_OVERRIDE"
          else
            echo "Error: Custom export options template not found at $EXPORT_TEMPLATE_OVERRIDE" >&2
            exit 1
          fi

      - name: Import codesign certs
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPSTORE_CERTIFICATES_FILE_BASE64 }}
          p12-password: ${{ secrets.APPSTORE_CERTIFICATES_PASSWORD }}

      - name: Import provisioning profiles
        run: |
          set -euo pipefail

          # Create provisioning profiles directory
          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILES_DIR"

          # Function to import a provisioning profile
          import_profile() {
            local platform=$1
            local profile_base64=$2
            local file_ext=$3

            if [ -z "$profile_base64" ]; then
              echo "Warning: $platform profile not provided, skipping"
              return 0
            fi

            echo "Importing $platform provisioning profile..."
            local temp_profile="$RUNNER_TEMP/${platform}${file_ext}"
            echo "$profile_base64" | base64 -d > "$temp_profile"

            # Extract UUID from profile using security cms
            local uuid=""
            local profile_xml=$(security cms -D -i "$temp_profile" 2>/dev/null || echo "")
            if [ -n "$profile_xml" ]; then
              uuid=$(echo "$profile_xml" | /usr/libexec/PlistBuddy -c "Print UUID" /dev/stdin 2>/dev/null || echo "")
            fi
            local profile_name=""
            local app_identifier=""
            local bundle_identifier=""
            if [ -n "$profile_xml" ]; then
              profile_name=$(echo "$profile_xml" | /usr/libexec/PlistBuddy -c "Print Name" /dev/stdin 2>/dev/null || echo "")
              app_identifier=$(echo "$profile_xml" | /usr/libexec/PlistBuddy -c "Print Entitlements:application-identifier" /dev/stdin 2>/dev/null || echo "")
              if [[ "$app_identifier" == *.* ]]; then
                bundle_identifier="${app_identifier#*.}"
              fi
            fi

            if [ -n "$uuid" ] && [ "$uuid" != "" ]; then
              cp "$temp_profile" "$PROFILES_DIR/$uuid${file_ext}"
              echo "✓ Imported $platform profile: $uuid"
            else
              # Fallback: use a generic name
              local fallback_name="${platform}${file_ext}"
              cp "$temp_profile" "$PROFILES_DIR/$fallback_name"
              echo "⚠ Imported $platform profile (UUID not found, using: $fallback_name)"
            fi

            if [ -n "$profile_name" ]; then
              echo "  Name: $profile_name"
            fi
            if [ -n "$bundle_identifier" ]; then
              echo "  Bundle Identifier: $bundle_identifier"
            fi

            # Export profile metadata for later steps (e.g., manual signing)
            local platform_upper
            platform_upper=$(echo "$platform" | tr '[:lower:]' '[:upper:]')
            platform_upper=$(echo "$platform_upper" | tr -cd 'A-Z0-9')
            if [ -n "$profile_name" ]; then
              printf "%s_PROVISIONING_PROFILE_NAME=%s\n" "$platform_upper" "$profile_name" >> "$GITHUB_ENV"
            fi
            if [ -n "$bundle_identifier" ]; then
              printf "%s_PROVISIONING_PROFILE_BUNDLE_ID=%s\n" "$platform_upper" "$bundle_identifier" >> "$GITHUB_ENV"
            fi
          }

          # Import profiles for each platform
          import_profile "iOS" "${IOS_PROVISIONING_PROFILE_BASE64:-}" ".mobileprovision"
          import_profile "macOS" "${MACOS_PROVISIONING_PROFILE_BASE64:-}" ".provisionprofile"
          import_profile "tvOS" "${TVOS_PROVISIONING_PROFILE_BASE64:-}" ".mobileprovision"

          # List imported profiles
          echo ""
          echo "Imported provisioning profiles:"
          ls -lh "$PROFILES_DIR" 2>/dev/null | tail -n +2 || echo "No profiles found"
        env:
          IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 || '' }}
          MACOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.MACOS_PROVISIONING_PROFILE_BASE64 || '' }}
          TVOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.TVOS_PROVISIONING_PROFILE_BASE64 || '' }}

      - name: Verify certificates and profiles
        run: |
          set -euo pipefail

          # List available certificates for debugging
          echo "Available signing certificates:"
          security find-identity -v -p codesigning | grep "Apple Distribution" || echo "No Apple Distribution certificate found"

          # List imported provisioning profiles
          PROFILES_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          echo ""
          echo "Available provisioning profiles:"
          ls -lh "$PROFILES_DIR" 2>/dev/null | tail -n +2 || echo "No profiles found"

          echo ""
          echo "xcodebuild will automatically select the appropriate certificate and provisioning profile"

      - name: Run make release
        env:
          APP_STORE_CONNECT_API_KEY_PATH: ${{ steps.prepare.outputs.APP_STORE_CONNECT_API_KEY_PATH }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        run: make release

      - name: Run make artifacts
        run: make artifacts

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: artifacts/*
          retention-days: 1

  publish:
    runs-on: ubuntu-latest
    needs: [detect, create, store]
    if: needs.detect.outputs.version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download release artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: artifacts

      - name: Upload to GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.detect.outputs.version }}
        run: |
          set -euo pipefail
          TAG="v${VERSION}"

          # Find all .ipa and .dmg files (already prepared with platform identifiers)
          ARTIFACTS=$(find artifacts -type f \( -name "*.ipa" -o -name "*.dmg" \) | sort)

          if [ -z "$ARTIFACTS" ]; then
            echo "No artifacts found"
            ls -la artifacts/ || true
            exit 1
          fi

          echo "Found artifacts (already prepared with platform identifiers):"
          echo "$ARTIFACTS"
          echo ""

          # Upload each artifact to GitHub Release
          for artifact in $ARTIFACTS; do
            echo "Uploading: $(basename "$artifact")"
            gh release upload "$TAG" "$artifact" --clobber
          done
